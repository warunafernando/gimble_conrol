<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gimbal Web GUI</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    :root {
      --bg: #0f0f12;
      --panel: #1a1a1f;
      --border: #2a2a32;
      --text: #e0e0e0;
      --accent: #4a9eff;
      --ok: #2ecc71;
      --err: #e74c3c;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 16px;
      min-height: 100vh;
    }
    h1 { font-size: 1.25rem; margin: 0 0 12px 0; color: var(--accent); display: flex; align-items: center; gap: 8px; }
    .fw-ver { font-size: 0.75rem; font-weight: normal; color: #888; }
    .fw-panel { min-width: 200px; }
    .fw-slot { font-size: 0.8rem; margin: 4px 0; }
    .fw-slot .label { color: #888; }
    .fw-slot.active .label { color: var(--ok); }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      min-width: 180px;
    }
    .panel h2 { font-size: 0.85rem; margin: 0 0 8px 0; color: #888; text-transform: uppercase; }
    .status { display: flex; align-items: center; gap: 8px; }
    .conn-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
    .conn-table th { text-align: left; padding: 6px 8px; color: #888; font-weight: normal; border-bottom: 1px solid var(--border); }
    .conn-table td { padding: 6px 8px; border-bottom: 1px solid var(--border); }
    .conn-table .status-ok { color: var(--ok); }
    .conn-table .status-no { color: #888; }
    .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-top: 6px; }
    input[type="text"], input[type="number"] {
      background: #25252d;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 6px;
      width: 70px;
      font-size: 0.85rem;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
    }
    button:hover { filter: brightness(1.1); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button.danger { background: var(--err); }
    button.warn { background: #d4a017; }
    .live { font-family: 'Consolas', monospace; font-size: 0.85rem; }
    .live .k { color: #888; }
    .live .v { color: #a8e6cf; }
    .debug {
      flex: 1;
      min-width: 320px;
      max-height: 280px;
      overflow-y: auto;
      font-family: 'Consolas', monospace;
      font-size: 0.75rem;
      line-height: 1.4;
      background: #0d0d10;
      padding: 10px;
      border-radius: 6px;
    }
    .debug .line { margin: 2px 0; color: #8a8a9a; }
    label { font-size: 0.8rem; color: #aaa; margin-right: 4px; }
    .btn-row { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    input[type="range"] { width: 120px; vertical-align: middle; }
    .slider-row { display: flex; align-items: center; gap: 8px; margin-top: 6px; }
    .slider-row label { min-width: 36px; }
    .slider-vertical-wrap {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 160px;
    }
    #sliderTilt {
      width: 160px;
      height: 20px;
      margin: 0;
      transform: rotate(-90deg);
      transform-origin: center center;
    }
    .move-content { display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap; }
    .move-sliders { flex: 0 0 auto; }
    .move-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 200px;
    }
    .move-buttons .btn-stop { margin-top: auto; }
    .state-lock-row { display: flex; flex-direction: row; gap: 20px; align-items: flex-start; }
    .state-lock-col { flex: 0 0 auto; }
    .state-lock-col h2 { margin: 0 0 8px 0; }
    .state-lock-col .btn-row { flex-direction: column; align-items: stretch; }
    .camera-panel { flex: 1; min-width: 320px; max-width: 40%; }
    .camera-wrap { background: #0d0d10; border-radius: 6px; overflow: hidden; max-height: 320px; }
    .camera-wrap img { display: block; width: 100%; max-height: 300px; object-fit: contain; }
    .camera-scan-panel { min-width: 220px; max-width: 280px; }
    .camera-scan-result { font-size: 0.8rem; margin-bottom: 8px; min-height: 2em; }
    .camera-list { display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto; }
    .camera-list .cam-item { display: flex; align-items: center; justify-content: space-between; gap: 8px; background: #25252d; padding: 8px 10px; border-radius: 4px; font-size: 0.85rem; }
    .camera-list .cam-item .cam-label { color: var(--text); flex: 1; min-width: 0; line-height: 1.3; }
    .camera-list .cam-item.current { border: 1px solid var(--ok); }
    .apriltag-panel { min-width: 200px; max-width: 250px; }
    .apriltag-list { font-family: 'Consolas', monospace; font-size: 0.85rem; max-height: 280px; overflow-y: auto; }
    .apriltag-item { background: #25252d; border-radius: 4px; padding: 8px 10px; margin-bottom: 6px; }
    .apriltag-item .tag-id { color: var(--accent); font-weight: bold; font-size: 1rem; }
    .apriltag-item .tag-pos { color: #a8e6cf; font-size: 0.8rem; margin-top: 4px; }
    .heading-gauge {
      width: 140px;
      height: 140px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .heading-gauge svg {
      display: block;
      width: 100%;
      height: 100%;
    }
    .heading-gauge .needle {
      transform-origin: 0 0;
      transition: transform 0.08s ease-out;
    }
    .heading-gauge .needle line {
      stroke: var(--accent);
      stroke-width: 2.5;
    }
    .heading-gauge .yaw-value {
      text-align: center;
      font-family: 'Consolas', monospace;
      font-size: 0.9rem;
      color: var(--accent);
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <h1>Gimbal Web GUI</h1>

  <div class="row">
    <div class="panel fw-panel" style="min-width: 320px;">
      <h2>Connection &amp; FW Info</h2>
      <table class="conn-table">
        <thead>
          <tr><th>COM port</th><th>Status</th><th>FW version</th><th>Serial</th><th></th></tr>
        </thead>
        <tbody>
          <tr>
            <td id="connPort">—</td>
            <td id="connStatus" class="status-no">Not connected</td>
            <td id="connFwVersion">—</td>
            <td id="connSerial">—</td>
            <td><button id="btnDisconnect" class="danger" type="button" disabled>Disconnect</button></td>
          </tr>
        </tbody>
      </table>
      <div style="margin-top: 10px;">
        <button id="btnRescan" type="button">Rescan and connect</button>
      </div>
    </div>
    <div class="panel">
      <h2>Live (move feedback)</h2>
      <pre class="live" id="liveMove">—</pre>
    </div>
    <div class="panel">
      <h2>IMU (last)</h2>
      <div class="btn-row" style="margin-bottom:6px">
        <button id="cmdGetImu">Get IMU (126)</button>
      </div>
      <pre class="live" id="liveImu">—</pre>
    </div>
    <div class="panel">
      <h2>Gyro / IMU</h2>
      <pre class="live" id="liveGyro">—</pre>
      <div class="live" style="font-size:0.8rem; color:#888; margin-top:4px;">Roll/Pitch/Yaw ° · Gyro °/s · used for track direction</div>
    </div>
    <div class="panel">
      <h2>Heading (Yaw)</h2>
      <div class="heading-gauge">
        <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <circle cx="50" cy="50" r="46" fill="none" stroke="var(--border)" stroke-width="2"/>
          <circle cx="50" cy="50" r="42" fill="var(--panel)" stroke="var(--border)" stroke-width="1"/>
          <line x1="50" y1="8" x2="50" y2="18" stroke="var(--text)" stroke-width="1.5" opacity="0.9"/>
          <line x1="50" y1="82" x2="50" y2="92" stroke="var(--text)" stroke-width="1" opacity="0.5"/>
          <line x1="8" y1="50" x2="18" y2="50" stroke="var(--text)" stroke-width="1" opacity="0.5"/>
          <line x1="82" y1="50" x2="92" y2="50" stroke="var(--text)" stroke-width="1" opacity="0.5"/>
          <!-- Fixed center hub (does not rotate) -->
          <circle cx="50" cy="50" r="5" fill="var(--accent)"/>
          <!-- Needle: pivot at center via translate(50,50) + rotate -->
          <g transform="translate(50, 50)">
            <g class="needle" id="headingNeedle" transform="rotate(0)">
              <line x1="0" y1="-40" x2="0" y2="40" stroke-linecap="round"/>
            </g>
          </g>
        </svg>
        <div class="yaw-value" id="yawValue">— °</div>
        <div style="margin-top:6px;font-size:0.75rem;color:#888;">
          <label>North offset (deg):</label>
          <input type="number" id="headingNorthOffset" value="0" min="-180" max="180" step="1" style="width:50px;"/>
          <span style="font-size:0.7rem;color:#666;">Add when facing North to get 0°</span>
        </div>
      </div>
    </div>
    <div class="panel">
      <h2>IMU2 - ICM42688</h2>
      <div class="btn-row" style="margin-bottom:6px">
        <button id="cmdGetImu2">Get IMU2 (127)</button>
      </div>
      <pre class="live" id="liveImu2">—</pre>
    </div>
    <div class="panel">
      <h2>INA (last)</h2>
      <div class="btn-row" style="margin-bottom:6px">
        <button id="cmdGetIna">Get INA (160)</button>
      </div>
      <pre class="live" id="liveIna">—</pre>
    </div>
    <div class="panel">
      <h2>Settings</h2>
      <div class="controls">
        <label>Feedback</label>
        <button id="cmdFbOn">On (131)</button>
        <button id="cmdFbOff">Off (131)</button>
      </div>
      <div class="controls" style="margin-top:6px">
        <label>Interval ms</label><input type="number" id="fbInterval" value="100" />
        <button id="cmdFbInterval">Set (142)</button>
      </div>
      <div class="controls" style="margin-top:6px">
        <label>Heartbeat ms</label><input type="number" id="heartbeatMs" value="0" />
        <button id="cmdHeartbeat">Set (136)</button>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="panel state-lock-row">
      <div class="state-lock-col">
        <h2>State</h2>
        <div class="status" style="margin-bottom:6px">
          <span class="live" id="liveGimbalState">—</span>
        </div>
        <div class="btn-row">
          <button id="cmdGetState">Get state (144)</button>
        </div>
        <div class="btn-row">
          <button id="cmdEnterTracking">Enter tracking (137)</button>
          <button id="cmdEnterConfig">Enter config (139)</button>
          <button id="cmdExitConfig">Exit config (140)</button>
        </div>
      </div>
      <div class="state-lock-col">
        <h2>Lock</h2>
        <div class="btn-row">
          <button id="cmdPanLock">Pan lock (170)</button>
          <button id="cmdPanUnlock">Pan unlock (170)</button>
          <button id="cmdTiltLock">Tilt lock (171)</button>
          <button id="cmdTiltUnlock">Tilt unlock (171)</button>
        </div>
      </div>
    </div>
    <div class="panel">
      <h2>Move</h2>
      <div class="move-content">
        <div class="move-sliders">
          <div class="slider-row">
            <label>Pan°</label>
            <input type="range" id="sliderPan" min="-180" max="180" value="0" step="1" />
            <input type="number" id="movePan" value="0" step="1" min="-180" max="180" style="width:56px" />
          </div>
          <div class="slider-row">
            <label>Tilt°</label>
            <div class="slider-vertical-wrap">
              <input type="range" id="sliderTilt" min="0" max="120" value="0" step="1" />
            </div>
            <input type="number" id="moveTilt" value="0" step="1" min="0" max="120" style="width:56px" />
          </div>
          <div class="controls">
            <label>Spd</label><input type="number" id="moveSpd" value="3400" />
            <label>Acc</label><input type="number" id="moveAcc" value="100" />
          </div>
        </div>
        <div class="move-buttons">
          <button id="cmdHome">Home (0°, 40°)</button>
          <button id="cmdPanTiltAbs">Pan+Tilt Abs (133)</button>
          <button id="cmdPanTiltMove">Pan+Tilt Move (134)</button>
          <button id="cmdPanOnlyAbs">Pan only Abs (172)</button>
          <button id="cmdTiltOnlyAbs">Tilt only Abs (173)</button>
          <button id="cmdPanOnlyMove">Pan only Move (174)</button>
          <button id="cmdTiltOnlyMove">Tilt only Move (175)</button>
          <button id="cmdStop" class="danger btn-stop">Stop (135)</button>
        </div>
      </div>
    </div>
    <div class="panel" id="configPanel">
      <h2>Config / diagnostics</h2>
      <div class="controls">
        <label>PING id</label><input type="number" id="pingId" value="1" min="1" max="254" />
        <button id="cmdPing">PING (200)</button>
      </div>
      <div class="controls" style="margin-top:6px">
        <label>Read id</label><input type="number" id="readId" value="1" />
        <label>addr</label><input type="number" id="readAddr" value="0" />
        <button id="cmdReadByte">Read byte (210)</button>
        <button id="cmdReadWord">Read word (212)</button>
      </div>
      <div class="controls" style="margin-top:6px">
        <label>Write id</label><input type="number" id="writeId" value="1" />
        <label>addr</label><input type="number" id="writeAddr" value="0" />
        <label>val</label><input type="number" id="writeVal" value="0" />
        <button id="cmdWriteByte">Write byte (211)</button>
        <button id="cmdWriteWord">Write word (213)</button>
      </div>
      <div class="controls" style="margin-top:6px">
        <label>Set ID from</label><input type="number" id="setIdFrom" value="1" />
        <label>to</label><input type="number" id="setIdTo" value="2" />
        <button id="cmdSetId" class="warn">Set servo ID (501)</button>
      </div>
      <div class="controls" style="margin-top:6px">
        <label>Calibrate id</label><input type="number" id="calId" value="1" />
        <button id="cmdCalibrate" class="warn">Calibrate (502)</button>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="panel">
      <h2>User ctrl (141)</h2>
      <div class="controls">
        <label>X</label><input type="number" id="userX" value="0" min="-1" max="2" />
        <label>Y</label><input type="number" id="userY" value="0" min="-1" max="2" />
        <label>Spd</label><input type="number" id="userSpd" value="300" />
        <button id="cmdUserCtrl">Send</button>
      </div>
    </div>
    <div class="panel" style="min-width: 220px;">
      <h2>Debug - I2C Scan</h2>
      <button id="cmdI2cScan">Scan I2C Bus (220)</button>
      <div id="i2cResult" style="margin-top:8px; font-family: 'Consolas', monospace; font-size: 0.8rem;">
        <span class="k">Devices:</span> <span id="i2cCount">—</span><br>
        <div id="i2cAddresses" style="margin-top:4px; color: #a8e6cf;"></div>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="panel" style="flex: 0 1 50%; min-width:200px; max-width:50%">
      <h2>Debug log</h2>
      <div class="debug" id="debugLog"></div>
      <button id="btnRefreshLog" style="margin-top:8px">Refresh log</button>
    </div>
    <div class="panel camera-scan-panel">
      <h2>Arducam / Camera</h2>
      <div class="controls" style="margin-bottom:8px">
        <button id="btnScanAndOpen">Scan & open (1200p @ 50 fps)</button>
      </div>
      <div id="cameraScanResult" class="camera-scan-result" style="font-size:0.85rem; color:#888;">
        <span id="cameraStatus">Click button to scan and open camera</span>
      </div>
      <div class="camera-current" style="margin-top:8px; font-size:0.8rem; color:#888;">
        Current: <span id="cameraCurrentIndex">—</span>
      </div>
    </div>
    <div class="panel camera-panel">
      <h2>Live camera</h2>
      <div class="camera-wrap">
        <img id="cameraFeed" src="" alt="Camera feed" style="display:none;" />
        <div id="cameraPlaceholder" style="padding:40px; text-align:center; color:#888;">Click Scan & open or Refresh stream</div>
      </div>
      <button id="btnRefreshCam" style="margin-top:8px">Refresh stream</button>
    </div>
    <div class="panel apriltag-panel">
      <h2>AprilTags Detected</h2>
      <div class="controls" style="margin-bottom:8px">
        <button id="btnAutoTrack" data-active="false" style="background:#555;">Auto-Track: OFF</button>
      </div>
      <div id="apriltagList" class="apriltag-list">
        <span style="color:#888;">No tags detected</span>
      </div>
    </div>
  </div>

  <script>
    var socketUrl = (window.location.origin && window.location.protocol && window.location.protocol.indexOf('http') === 0)
      ? window.location.origin
      : 'http://localhost:5000';
    const socket = io(socketUrl, { transports: ['websocket', 'polling'], reconnection: true, reconnectionAttempts: 20, reconnectionDelay: 2000 });
    const connStatusEl = document.getElementById('connStatus');
    const connPortEl = document.getElementById('connPort');
    const connFwVersionEl = document.getElementById('connFwVersion');
    const connSerialEl = document.getElementById('connSerial');
    const btnDisconnect = document.getElementById('btnDisconnect');
    const btnRescan = document.getElementById('btnRescan');
    let connectionState = { connected: false };
    const liveMove = document.getElementById('liveMove');
    const liveImu = document.getElementById('liveImu');
    const liveIna = document.getElementById('liveIna');
    const debugLog = document.getElementById('debugLog');
    const configPanel = document.getElementById('configPanel');
    let gimbalState = 'idle';

    function floatToBytes(f) {
      const buf = new ArrayBuffer(4);
      new DataView(buf).setFloat32(0, f, true);
      return Array.from(new Uint8Array(buf));
    }
    function u16ToBytes(n) {
      n = n >>> 0;
      return [n & 0xff, (n >> 8) & 0xff];
    }
    function i8ToByte(x) {
      return ((x << 24) >> 24) & 0xff;
    }
    function sendCommand(typeId, payload) {
      const pl = payload == null ? [] : (Array.isArray(payload) ? payload : Array.from(payload));
      socket.emit('command', { type: typeId, payload: pl });
    }

    function setConnected(connected) {
      connectionState.connected = connected;
      connStatusEl.textContent = connected ? 'Connected' : 'Not connected';
      connStatusEl.className = connected ? 'status-ok' : 'status-no';
      btnDisconnect.disabled = !connected;
    }

    socket.on('state', function (s) {
      setConnected(s.connected);
      if (connPortEl) connPortEl.textContent = (s.port && s.port.trim()) ? s.port : '—';
      if (connSerialEl) connSerialEl.textContent = (s.gimbal_serial !== undefined && s.gimbal_serial !== null) ? String(s.gimbal_serial) : '—';
      if (connFwVersionEl) {
        if (s.fw_info) {
          var active = s.fw_info.active_slot === 0 ? 0 : 1;
          var v = active === 0 ? (s.fw_info.version_a || '—') : (s.fw_info.version_b || '—');
          connFwVersionEl.textContent = (v && v.trim()) ? v.trim() : '—';
        } else connFwVersionEl.textContent = '—';
      }
      if (s.fw_info) updateFwDisplay(s.fw_info);
      if (s.last_imu && s.last_imu.yaw != null) {
        lastImu = s.last_imu;
        updateHeadingNeedle(s.last_imu.yaw);
      }
    });
    socket.on('fw_info', function (fw) {
      updateFwDisplay(fw || {});
    });
    // Servo position: raw 0-4095, center 2048 ~ 0 deg. deg = (raw - 2048) * (360/4095)
    const PAN_CENTER_RAW = 2048;
    const PAN_RAW_TO_DEG = 360 / 4095;
    function panRawToDeg(raw) {
      return (raw - PAN_CENTER_RAW) * PAN_RAW_TO_DEG;
    }

    // AprilTag auto-tracking state
    let autoTrackEnabled = false;
    let scanDirection = 1; // 1 = right, -1 = left
    let currentPan = 0;
    let lastPanPosRaw = null;      // from move feedback (int16)
    let lastPanPosDeg = null;      // converted to degrees for commands
    let lastTagCenterX = null;     // last known tag X when we had a tag (for recover direction)
    let lastImu = null;            // last IMU (roll, pitch, yaw, gx, gy, gz) for display and direction
    const FRAME_WIDTH = 1920;
    const FRAME_CENTER_X = 960;
    var effectiveFrameCenterX = 960;  // Updated from /api/cameras/current (width/2) so tag centers correctly
    const SCAN_SPEED = 800;        // Fast when searching
    const SCAN_STEP = 8;           // degrees per step when searching
    const RECOVER_SPEED = 500;     // speed when moving toward lost tag
    const RECOVER_STEP = 4;        // degrees per step when recovering
    const CENTER_THRESHOLD = 35;   // pixels from center to consider "centered"
    const TRACK_SPEED_FAST = 400;  // when tag is far from center
    const TRACK_SPEED_SLOW = 80;   // when tag is close (avoid oscillation)
    const TRACK_ZONE = 120;       // pixels: inside this = slow, outside = fast
    let scanInterval = null;
    let recoverInterval = null;
    let recoverDirection = 1;      // 1 = pan right, -1 = pan left

    socket.on('apriltags', function (data) {
      const list = document.getElementById('apriltagList');
      const tags = data.tags || [];
      if (tags.length === 0) {
        list.innerHTML = '<span style="color:#888;">No tags detected</span>';
      } else {
        list.innerHTML = tags.map(function(t) {
          return '<div class="apriltag-item">' +
            '<div class="tag-id">Tag #' + t.id + '</div>' +
            '<div class="tag-pos">Center: (' + t.center_x + ', ' + t.center_y + ')</div>' +
            '</div>';
        }).join('');
      }

      // Auto-tracking logic
      if (autoTrackEnabled) {
        // Check if serial is connected before sending commands
        const connected = connectionState.connected;
        if (!connected) {
          // Disable auto-track if connection lost
          autoTrackEnabled = false;
          const btn = document.getElementById('btnAutoTrack');
          btn.setAttribute('data-active', 'false');
          btn.textContent = 'Auto-Track: OFF';
          btn.style.background = '#555';
          if (scanInterval) {
            clearInterval(scanInterval);
            scanInterval = null;
          }
          if (recoverInterval) {
            clearInterval(recoverInterval);
            recoverInterval = null;
          }
          return;
        }
        
        if (tags.length > 0) {
          // Tag found - remember position and keep centered
          const tag = tags[0];
          lastTagCenterX = tag.center_x;
          if (recoverInterval) {
            clearInterval(recoverInterval);
            recoverInterval = null;
          }

          const centerX = effectiveFrameCenterX;
          const offsetX = tag.center_x - centerX;
          const absOffset = Math.abs(offsetX);

          if (absOffset > CENTER_THRESHOLD) {
            // Tag not centered - speed and step depend on distance
            const inSlowZone = absOffset < TRACK_ZONE;
            const panStep = inSlowZone ? 0.4 : 2;
            const speed = inSlowZone ? TRACK_SPEED_SLOW : TRACK_SPEED_FAST;
            currentPan += offsetX > 0 ? panStep : -panStep;
            currentPan = Math.max(-180, Math.min(180, currentPan));
            if (scanInterval) {
              clearInterval(scanInterval);
              scanInterval = null;
            }
            sendCommand(172, floatToBytes(currentPan).concat(u16ToBytes(speed), u16ToBytes(50)));
          } else {
            // Centered - stop
            if (scanInterval) {
              clearInterval(scanInterval);
              scanInterval = null;
            }
            sendCommand(135, []);
          }
        } else {
          // No tag - move toward where we lost it: use actual pan from feedback + tag position
          if (lastTagCenterX !== null) {
            // Use actual gimbal position so we step from reality (fixes wrong-way when currentPan drifted)
            if (lastPanPosDeg != null) {
              currentPan = lastPanPosDeg;
            }
            // Shortest way: tag left of center → it exited left → pan left (decrease). Tag right → pan right (increase).
            recoverDirection = lastTagCenterX < effectiveFrameCenterX ? -1 : 1;
            startRecoverInterval();
          } else {
            startScanInterval();
          }
        }
      }
    });

    // Start scanning (used when auto-track ON, no tag, never had tag)
    function startScanInterval() {
      if (scanInterval) return;
      if (recoverInterval) {
        clearInterval(recoverInterval);
        recoverInterval = null;
      }
      scanInterval = setInterval(function() {
        const connected = connectionState.connected;
        if (!connected) return;
        currentPan += SCAN_STEP * scanDirection;
        if (currentPan >= 180 || currentPan <= -180) {
          scanDirection *= -1;
          currentPan = Math.max(-180, Math.min(180, currentPan));
        }
        sendCommand(172, floatToBytes(currentPan).concat(u16ToBytes(SCAN_SPEED), u16ToBytes(50)));
      }, 300);
    }

    // Move toward where tag was lost (shortest way), using actual pan from feedback
    function startRecoverInterval() {
      if (recoverInterval) return;
      if (scanInterval) {
        clearInterval(scanInterval);
        scanInterval = null;
      }
      recoverInterval = setInterval(function() {
        const connected = connectionState.connected;
        if (!connected) return;
        if (lastPanPosDeg != null) currentPan = lastPanPosDeg;
        currentPan += RECOVER_STEP * recoverDirection;
        currentPan = Math.max(-180, Math.min(180, currentPan));
        if (currentPan >= 180 || currentPan <= -180) {
          recoverDirection *= -1;
        }
        sendCommand(172, floatToBytes(currentPan).concat(u16ToBytes(RECOVER_SPEED), u16ToBytes(50)));
      }, 200);
    }

    // Auto-track toggle button
    document.getElementById('btnAutoTrack').onclick = function() {
      // Check if serial is connected
      const connected = connectionState.connected;
      if (!connected) {
        alert('Gimbal not connected. Plug in the device or click Re-scan.');
        return;
      }
      
      autoTrackEnabled = !autoTrackEnabled;
      const btn = document.getElementById('btnAutoTrack');
      btn.setAttribute('data-active', autoTrackEnabled);
      btn.textContent = autoTrackEnabled ? 'Auto-Track: ON' : 'Auto-Track: OFF';
      btn.style.background = autoTrackEnabled ? 'var(--ok)' : '#555';
      
      if (!autoTrackEnabled) {
        if (scanInterval) {
          clearInterval(scanInterval);
          scanInterval = null;
        }
        if (recoverInterval) {
          clearInterval(recoverInterval);
          recoverInterval = null;
        }
        sendCommand(135, []);
      } else {
        // Turned ON: start scanning immediately (don't wait for apriltags event)
        startScanInterval();
      }
    };

    socket.on('i2c_scan', function (data) {
      document.getElementById('i2cCount').textContent = data.count || 0;
      const addrDiv = document.getElementById('i2cAddresses');
      const deviceIds = data.device_ids || {};
      if (data.hex_addresses && data.hex_addresses.length > 0) {
        addrDiv.innerHTML = data.hex_addresses.map(function(addr) {
          var dev = deviceIds[addr];
          var label = addr;
          if (dev && (dev.who75 !== 255 || dev.who00 !== 255)) {
            var n = dev.name75 || dev.name00 || '';
            if (!n) n = 'WHO75=' + (dev.who75 !== 255 ? '0x' + dev.who75.toString(16).toUpperCase() : '?') +
                         ' WHO00=' + (dev.who00 !== 255 ? '0x' + dev.who00.toString(16).toUpperCase() : '?');
            label = addr + ' (' + n + ')';
          }
          return '<span style="display:inline-block;margin:2px 4px;padding:2px 6px;background:#25252d;border-radius:4px;" title="' + addr + '">' + label + '</span>';
        }).join('');
      } else {
        addrDiv.innerHTML = '<span style="color:#888;">No devices found</span>';
      }
    });
    socket.on('imu2', function (data) {
      const el = document.getElementById('liveImu2');
      if (el && data) {
        el.innerHTML = '<span class="k">Accel:</span> <span class="v">' + (data.ax || 0).toFixed(3) + '</span> <span class="v">' + (data.ay || 0).toFixed(3) + '</span> <span class="v">' + (data.az || 0).toFixed(3) + '</span> g\n' +
                       '<span class="k">Gyro:</span> <span class="v">' + (data.gx || 0).toFixed(1) + '</span> <span class="v">' + (data.gy || 0).toFixed(1) + '</span> <span class="v">' + (data.gz || 0).toFixed(1) + '</span> °/s\n' +
                       '<span class="k">Temp:</span> <span class="v">' + (data.temp || 0).toFixed(1) + '</span> °C';
      }
    });
    socket.on('frame', function (data) {
      if (data.payload) {
        if (data.type === 2 && data.payload.pan_pos !== undefined) {
          const p = data.payload;
          lastPanPosRaw = p.pan_pos;
          lastPanPosDeg = panRawToDeg(p.pan_pos);
          currentPan = lastPanPosDeg;  // keep commanded pan in sync with actual for recovery
          let moveText = `pan_pos ${p.pan_pos}  pan_load ${p.pan_load}\ntilt_pos ${p.tilt_pos}  tilt_load ${p.tilt_load}`;
          if (lastImu != null && (lastImu.gx != null || lastImu.gy != null || lastImu.gz != null)) {
            const gx = lastImu.gx != null ? lastImu.gx.toFixed(1) : '—';
            const gy = lastImu.gy != null ? lastImu.gy.toFixed(1) : '—';
            const gz = lastImu.gz != null ? lastImu.gz.toFixed(1) : '—';
            moveText += '\nGyro gx ' + gx + '  gy ' + gy + '  gz ' + gz + ' °/s';
          }
          liveMove.textContent = moveText;
        } else if (data.type === 1002) {
          const i = data.payload;
          lastImu = i;
          liveImu.textContent = `r ${(i.roll||0).toFixed(2)}  p ${(i.pitch||0).toFixed(2)}  y ${(i.yaw||0).toFixed(2)}`;
          const gyroEl = document.getElementById('liveGyro');
          if (gyroEl) {
            gyroEl.textContent = 'Roll ' + (i.roll != null ? i.roll.toFixed(2) : '—') + '°  Pitch ' + (i.pitch != null ? i.pitch.toFixed(2) : '—') + '°  Yaw ' + (i.yaw != null ? i.yaw.toFixed(2) : '—') + '°\n' +
              'Gyro gx ' + (i.gx != null ? i.gx.toFixed(1) : '—') + '  gy ' + (i.gy != null ? i.gy.toFixed(1) : '—') + '  gz ' + (i.gz != null ? i.gz.toFixed(1) : '—') + ' °/s';
          }
          updateHeadingNeedle(i.yaw);
        } else if (data.type === 1003) {
          const i = data.payload;
          const el = document.getElementById('liveImu2');
          if (el && i) {
            el.innerHTML = '<span class="k">Accel:</span> <span class="v">' + (i.ax || 0).toFixed(3) + '</span> <span class="v">' + (i.ay || 0).toFixed(3) + '</span> <span class="v">' + (i.az || 0).toFixed(3) + '</span> g\n' +
                           '<span class="k">Gyro:</span> <span class="v">' + (i.gx || 0).toFixed(1) + '</span> <span class="v">' + (i.gy || 0).toFixed(1) + '</span> <span class="v">' + (i.gz || 0).toFixed(1) + '</span> °/s\n' +
                           '<span class="k">Temp:</span> <span class="v">' + (i.temp || 0).toFixed(1) + '</span> °C';
          }
        } else if (data.type === 1010) {
          const a = data.payload || {};
          if (a.error) {
            liveIna.textContent = `INA error: ${a.error} (len=${a.len}${a.expected != null ? ', expected ' + a.expected : ''})`;
          } else {
            liveIna.textContent = `bus_v ${(a.bus_v != null ? a.bus_v : 0).toFixed(3)} V  load_v ${(a.load_v != null ? a.load_v : 0).toFixed(3)} V\ncurrent_ma ${(a.current_ma != null ? a.current_ma : 0).toFixed(2)} mA  power_mw ${(a.power_mw != null ? a.power_mw : 0).toFixed(1)} mW\nshunt_mv ${(a.shunt_mv != null ? a.shunt_mv : 0).toFixed(2)} mV  overflow ${a.overflow != null ? a.overflow : 0}`;
          }
        } else if (Number(data.type) === 2610) {
          updateFwDisplay(data.payload || {});
        } else if (data.type === 1013) {
          const g = data.payload || {};
          const name = g.stateName != null ? g.stateName : (g.state === 0 ? 'idle' : g.state === 1 ? 'tracking' : g.state === 2 ? 'config' : '?');
          const liveGimbalState = document.getElementById('liveGimbalState');
          if (liveGimbalState) liveGimbalState.textContent = 'ESP32: ' + name;
          gimbalState = name;
          setConfigVisible(name !== 'tracking');
        }
      }
    });
    socket.on('log_line', function (data) {
      const div = document.createElement('div');
      div.className = 'line';
      div.textContent = data.line;
      debugLog.appendChild(div);
      debugLog.scrollTop = debugLog.scrollHeight;
    });
    socket.on('log_history', function (data) {
      debugLog.innerHTML = (data.lines || []).map(l => `<div class="line">${escapeHtml(l)}</div>`).join('');
      debugLog.scrollTop = debugLog.scrollHeight;
    });
    socket.on('connect', function () {
      connStatusEl.textContent = 'Not connected';
      connStatusEl.className = 'status-no';
    });
    socket.on('disconnect', function (reason) {
      connStatusEl.textContent = 'Server disconnected. Reconnecting…';
      connStatusEl.className = 'status-no';
    });
    socket.on('connect_error', function (err) {
      connStatusEl.textContent = 'Cannot reach server';
      connStatusEl.className = 'status-no';
      console.error('Socket connect_error:', err.message);
    });
    socket.on('connect_serial_result', function (data) {
      setConnected(data.ok);
      if (!data.ok) alert('Failed to connect to ' + (data.port || '') + (data.error ? '\n' + data.error : ''));
    });
    socket.on('error', function (data) { alert(data.msg || 'Error'); });

    let lastHeadingYaw = null;
    let lastUnwrappedDisplay = null;
    function updateHeadingNeedle(yawDeg) {
      const needle = document.getElementById('headingNeedle');
      const yawEl = document.getElementById('yawValue');
      if (!needle || !yawEl) return;
      if (yawDeg == null || Number.isNaN(yawDeg)) {
        lastHeadingYaw = null;
        lastUnwrappedDisplay = null;
        yawEl.textContent = '— °';
        needle.setAttribute('transform', 'rotate(0)');
        return;
      }
      var displayAngle;
      if (lastHeadingYaw == null) {
        displayAngle = yawDeg;
      } else {
        var delta = yawDeg - lastHeadingYaw;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        displayAngle = lastUnwrappedDisplay + delta;
      }
      lastHeadingYaw = yawDeg;
      lastUnwrappedDisplay = displayAngle;
      var northOffset = parseFloat(document.getElementById('headingNorthOffset').value) || 0;
      var displayCorrected = displayAngle + 180 + northOffset;  // sensor +180 + North offset
      needle.setAttribute('transform', 'rotate(' + displayCorrected + ')');
      var showVal = (((displayCorrected % 360) + 360) % 360);
      yawEl.textContent = showVal.toFixed(1) + ' °';
    }
    document.getElementById('headingNorthOffset').oninput = function() {
      if (lastHeadingYaw != null) updateHeadingNeedle(lastHeadingYaw);
    };
    function updateFwDisplay(fw) {
      if (!fw) return;
      var active = fw.active_slot === 0 ? 0 : 1;
      var vTitle = active === 0 ? ((fw.version_a || '').trim() || '—') : ((fw.version_b || '').trim() || '—');
      if (connFwVersionEl) connFwVersionEl.textContent = (vTitle && vTitle !== '—') ? vTitle : '—';
      if (connSerialEl) {
        var serialVal = fw.serial;
        connSerialEl.textContent = (serialVal !== undefined && serialVal !== null) ? String(serialVal) : '—';
      }
    }
    function escapeHtml(s) {
      const d = document.createElement('div');
      d.textContent = s;
      return d.innerHTML;
    }

    btnRescan.onclick = function () {
      fetch('/api/rescan_serial', { method: 'POST' })
        .then(function(r) { return r.json(); })
        .then(function(d) {
          if (d.ok) connStatusEl.textContent = d.message === 'Already connected' ? 'Connected' : 'Rescanning…';
        })
        .catch(function() {});
    };
    btnDisconnect.onclick = function () { socket.emit('disconnect_serial'); };
    btnRefreshLog.onclick = function () { socket.emit('get_log'); };

    // Camera: one button = scan + open 1200p @ 50 fps + start stream
    var CAMERA_1200P = { width: 1920, height: 1200, fps: 50 };
    function refreshCameraCurrent() {
      fetch('/api/cameras/current')
        .then(function(r) { return r.json(); })
        .then(function(d) {
          var el = document.getElementById('cameraCurrentIndex');
          if (el) el.textContent = d.ok ? ('Index ' + d.index + ', ' + (d.width || 1920) + '×' + (d.height || 1200) + ' @ ' + (d.fps != null ? d.fps : 50) + ' fps') : '—';
          if (d.ok && d.width != null && d.width > 0) effectiveFrameCenterX = d.width / 2;
        })
        .catch(function() {
          var el = document.getElementById('cameraCurrentIndex');
          if (el) el.textContent = '—';
        });
    }
    function startCameraFeed() {
      var img = document.getElementById('cameraFeed');
      var placeholder = document.getElementById('cameraPlaceholder');
      placeholder.textContent = 'Loading camera...';
      placeholder.style.display = 'block';
      img.style.display = 'none';
      fetch('/api/cameras/current')
        .then(function(r) { return r.json(); })
        .then(function(d) {
          var idx = (d.ok && d.index != null) ? d.index : 0;
          return fetch('/api/cameras/select', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: idx, width: CAMERA_1200P.width, height: CAMERA_1200P.height, fps: CAMERA_1200P.fps })
          });
        })
        .then(function(r) { return r.json(); })
        .then(function(res) {
          if (res && res.ok) refreshCameraCurrent();
        })
        .catch(function() {})
        .finally(function() {
          img.src = '/video_feed?' + Date.now();
        });
      img.onload = function() {
        img.style.display = 'block';
        placeholder.style.display = 'none';
      };
      img.onerror = function() {
        placeholder.textContent = 'Camera not available - try Scan & open';
        placeholder.style.display = 'block';
        img.style.display = 'none';
      };
      setTimeout(function() {
        if (img.style.display === 'none' && img.src) {
          placeholder.textContent = 'Still loading… If no picture, try Refresh stream';
        }
      }, 8000);
      setTimeout(function() {
        if (img.style.display === 'none' && img.src) {
          img.style.display = 'block';
          placeholder.style.display = 'none';
        }
      }, 20000);
    }
    document.getElementById('btnScanAndOpen').onclick = function() {
      var statusEl = document.getElementById('cameraStatus');
      statusEl.textContent = 'Scanning...';
      fetch('/api/cameras')
        .then(function(r) {
          if (!r.ok) {
            return r.text().then(function(t) { return Promise.reject(new Error('Scan: ' + r.status + (t ? ' ' + t.slice(0, 80) : ''))); });
          }
          return r.json();
        })
        .then(function(d) {
          if (!d || !d.ok) {
            statusEl.textContent = (d && d.error) || 'Scan failed';
            return Promise.reject(new Error('Scan failed'));
          }
          var cams = d.cameras || [];
          var idx = cams.length ? cams[0].index : 0;
          statusEl.textContent = 'Found ' + cams.length + ' camera(s). Opening 1200p @ 50 fps...';
          return fetch('/api/cameras/select', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: idx, width: CAMERA_1200P.width, height: CAMERA_1200P.height, fps: CAMERA_1200P.fps })
          });
        })
        .then(function(r) {
          if (!r.ok) {
            return r.text().then(function(t) { return Promise.reject(new Error('Select: ' + r.status + (t ? ' ' + t.slice(0, 80) : ''))); });
          }
          return r.json();
        })
        .then(function(res) {
          if (res && res.ok) {
            statusEl.textContent = 'Camera set to 1200p @ 50 fps';
            refreshCameraCurrent();
            startCameraFeed();
          } else {
            statusEl.textContent = (res && res.error) || 'Select failed';
          }
        })
        .catch(function(e) {
          var msg = (e && e.message) ? e.message : String(e);
          if (statusEl.textContent.indexOf('Scan failed') === -1 && statusEl.textContent.indexOf('Select failed') === -1) {
            statusEl.textContent = msg.indexOf('Failed to fetch') !== -1 ? 'Server not reachable – is the backend running?' : ('Error: ' + msg);
          }
        });
    };
    document.getElementById('btnRefreshCam').onclick = startCameraFeed;
    refreshCameraCurrent();

    function setConfigVisible(visible) {
      configPanel.style.display = visible ? 'block' : 'none';
    }

    // State
    document.getElementById('cmdGetState').onclick = function () { sendCommand(144, []); };
    document.getElementById('cmdEnterTracking').onclick = function () {
      sendCommand(137, []);
      gimbalState = 'tracking';
      setConfigVisible(false);
    };
    document.getElementById('cmdEnterConfig').onclick = function () {
      sendCommand(139, []);
      gimbalState = 'config';
      setConfigVisible(true);
    };
    document.getElementById('cmdExitConfig').onclick = function () {
      sendCommand(140, []);
      gimbalState = 'idle';
      setConfigVisible(true);
    };

    // Move
    function getMove() {
      const pan = parseFloat(document.getElementById('movePan').value) || 0;
      const tilt = parseFloat(document.getElementById('moveTilt').value) || 0;
      const spd = parseInt(document.getElementById('moveSpd').value, 10) || 3400;
      const acc = parseInt(document.getElementById('moveAcc').value, 10) || 100;
      return { pan, tilt, spd, acc };
    }
    document.getElementById('cmdHome').onclick = function () {
      const m = getMove();
      sendCommand(133, floatToBytes(0).concat(floatToBytes(40), u16ToBytes(m.spd), u16ToBytes(m.acc)));
      document.getElementById('sliderPan').value = 0;
      document.getElementById('movePan').value = 0;
      document.getElementById('sliderTilt').value = 40;
      document.getElementById('moveTilt').value = 40;
    };
    document.getElementById('cmdPanTiltAbs').onclick = function () {
      const m = getMove();
      sendCommand(133, floatToBytes(m.pan).concat(floatToBytes(m.tilt), u16ToBytes(m.spd), u16ToBytes(m.acc)));
    };
    document.getElementById('cmdPanTiltMove').onclick = function () {
      const m = getMove();
      sendCommand(134, floatToBytes(m.pan).concat(floatToBytes(m.tilt), u16ToBytes(m.spd), u16ToBytes(m.spd)));
    };
    document.getElementById('cmdPanOnlyAbs').onclick = function () {
      const m = getMove();
      sendCommand(172, floatToBytes(m.pan).concat(u16ToBytes(m.spd), u16ToBytes(m.acc)));
    };
    document.getElementById('cmdTiltOnlyAbs').onclick = function () {
      const m = getMove();
      sendCommand(173, floatToBytes(m.tilt).concat(u16ToBytes(m.spd), u16ToBytes(m.acc)));
    };
    document.getElementById('cmdPanOnlyMove').onclick = function () {
      const m = getMove();
      sendCommand(174, floatToBytes(m.pan).concat(u16ToBytes(m.spd)));
    };
    document.getElementById('cmdTiltOnlyMove').onclick = function () {
      const m = getMove();
      sendCommand(175, floatToBytes(m.tilt).concat(u16ToBytes(m.spd)));
    };
    document.getElementById('cmdStop').onclick = function () {
      sendCommand(135, []);
      gimbalState = 'idle';
      setConfigVisible(true);
    };

    // Sliders sync with number inputs (Move) and send to motor when updated (debounced)
    const sliderPan = document.getElementById('sliderPan');
    const sliderTilt = document.getElementById('sliderTilt');
    const movePanInput = document.getElementById('movePan');
    const moveTiltInput = document.getElementById('moveTilt');
    const SLIDER_DEBOUNCE_MS = 120;
    let panSliderDebounce = null;
    let tiltSliderDebounce = null;
    sliderPan.addEventListener('input', function () {
      movePanInput.value = sliderPan.value;
      clearTimeout(panSliderDebounce);
      panSliderDebounce = setTimeout(function () {
        const m = getMove();
        const pan = parseFloat(sliderPan.value) || 0;
        sendCommand(172, floatToBytes(pan).concat(u16ToBytes(m.spd), u16ToBytes(m.acc)));
        panSliderDebounce = null;
      }, SLIDER_DEBOUNCE_MS);
    });
    sliderTilt.addEventListener('input', function () {
      moveTiltInput.value = sliderTilt.value;
      clearTimeout(tiltSliderDebounce);
      tiltSliderDebounce = setTimeout(function () {
        const m = getMove();
        const tilt = parseFloat(sliderTilt.value) || 0;
        sendCommand(173, floatToBytes(tilt).concat(u16ToBytes(m.spd), u16ToBytes(m.acc)));
        tiltSliderDebounce = null;
      }, SLIDER_DEBOUNCE_MS);
    });
    movePanInput.addEventListener('input', function () {
      const v = Math.max(-180, Math.min(180, parseInt(movePanInput.value, 10) || 0));
      sliderPan.value = v;
      movePanInput.value = v;
    });
    moveTiltInput.addEventListener('input', function () {
      const v = Math.max(0, Math.min(120, parseInt(moveTiltInput.value, 10) || 0));
      sliderTilt.value = v;
      moveTiltInput.value = v;
    });

    // Lock
    document.getElementById('cmdPanLock').onclick = function () { sendCommand(170, [1]); };
    document.getElementById('cmdPanUnlock').onclick = function () { sendCommand(170, [0]); };
    document.getElementById('cmdTiltLock').onclick = function () { sendCommand(171, [1]); };
    document.getElementById('cmdTiltUnlock').onclick = function () { sendCommand(171, [0]); };

    // Settings
    document.getElementById('cmdFbOn').onclick = function () { sendCommand(131, [1]); };
    document.getElementById('cmdFbOff').onclick = function () { sendCommand(131, [0]); };
    document.getElementById('cmdFbInterval').onclick = function () {
      const ms = parseInt(document.getElementById('fbInterval').value, 10) || 100;
      sendCommand(142, u16ToBytes(ms));
    };
    document.getElementById('cmdHeartbeat').onclick = function () {
      const ms = parseInt(document.getElementById('heartbeatMs').value, 10) || 0;
      sendCommand(136, u16ToBytes(ms));
    };

    // User ctrl (141): X(1), Y(1), SPD(2)
    document.getElementById('cmdUserCtrl').onclick = function () {
      const x = parseInt(document.getElementById('userX').value, 10) || 0;
      const y = parseInt(document.getElementById('userY').value, 10) || 0;
      const spd = parseInt(document.getElementById('userSpd').value, 10) || 300;
      sendCommand(141, [i8ToByte(x), i8ToByte(y)].concat(u16ToBytes(spd)));
    };

    // Query - with debounce to prevent rapid-fire clicks
    let lastCmdTime = {};
    function throttledCommand(cmd, payload, minInterval = 200) {
      const now = Date.now();
      if (lastCmdTime[cmd] && (now - lastCmdTime[cmd]) < minInterval) {
        console.log(`Throttled command ${cmd} (too fast)`);
        return;
      }
      lastCmdTime[cmd] = now;
      sendCommand(cmd, payload);
    }
    
    document.getElementById('cmdGetImu').onclick = function () { throttledCommand(126, [], 200); };
    document.getElementById('cmdGetImu2').onclick = function () { throttledCommand(127, [], 200); };
    document.getElementById('cmdGetIna').onclick = function () { throttledCommand(160, [], 200); };
    document.getElementById('cmdGetFwInfo').onclick = function () { throttledCommand(610, [], 500); };
    document.getElementById('cmdI2cScan').onclick = function () { throttledCommand(220, [], 500); };

    // Config / diagnostics
    document.getElementById('cmdPing').onclick = function () {
      const id = parseInt(document.getElementById('pingId').value, 10) || 1;
      sendCommand(200, [id]);
    };
    document.getElementById('cmdReadByte').onclick = function () {
      const id = parseInt(document.getElementById('readId').value, 10) || 1;
      const addr = parseInt(document.getElementById('readAddr').value, 10) || 0;
      sendCommand(210, [id, addr]);
    };
    document.getElementById('cmdReadWord').onclick = function () {
      const id = parseInt(document.getElementById('readId').value, 10) || 1;
      const addr = parseInt(document.getElementById('readAddr').value, 10) || 0;
      sendCommand(212, [id, addr]);
    };
    document.getElementById('cmdWriteByte').onclick = function () {
      const id = parseInt(document.getElementById('writeId').value, 10) || 1;
      const addr = parseInt(document.getElementById('writeAddr').value, 10) || 0;
      const val = parseInt(document.getElementById('writeVal').value, 10) & 0xff;
      sendCommand(211, [id, addr, val]);
    };
    document.getElementById('cmdWriteWord').onclick = function () {
      const id = parseInt(document.getElementById('writeId').value, 10) || 1;
      const addr = parseInt(document.getElementById('writeAddr').value, 10) || 0;
      const val = parseInt(document.getElementById('writeVal').value, 10) & 0xffff;
      sendCommand(213, [id, addr].concat(u16ToBytes(val)));
    };
    document.getElementById('cmdSetId').onclick = function () {
      if (!confirm('Set servo ID changes hardware. Continue?')) return;
      const fromId = parseInt(document.getElementById('setIdFrom').value, 10) || 1;
      const toId = parseInt(document.getElementById('setIdTo').value, 10) || 2;
      sendCommand(501, [fromId, toId]);
    };
    document.getElementById('cmdCalibrate').onclick = function () {
      if (!confirm('Calibrate sets current position as middle. Continue?')) return;
      const id = parseInt(document.getElementById('calId').value, 10) || 1;
      sendCommand(502, [id]);
    };
  </script>
</body>
</html>
